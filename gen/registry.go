// Code generated by generate-go-extensions. DO NOT EDIT.

package gen

import (
	"encoding/xml"
	"fmt"
	"reflect"
	"strings"

	// Auto-generated imports for all DDEX message types
	ernv381 "github.com/OpenAudio/ddex-proto/gen/ddex/ern/v381"
	ernv383 "github.com/OpenAudio/ddex-proto/gen/ddex/ern/v383"
	ernv42 "github.com/OpenAudio/ddex-proto/gen/ddex/ern/v42"
	ernv43 "github.com/OpenAudio/ddex-proto/gen/ddex/ern/v43"
	ernv432 "github.com/OpenAudio/ddex-proto/gen/ddex/ern/v432"
	meadv11 "github.com/OpenAudio/ddex-proto/gen/ddex/mead/v11"
	piev10 "github.com/OpenAudio/ddex-proto/gen/ddex/pie/v10"
)

// MessageTypeInfo holds information about a registered DDEX message type
type MessageTypeInfo struct {
	Type        reflect.Type
	Namespace   string
	RootElement string
}

// messageRegistry maps "messageType/version" to MessageTypeInfo
var messageRegistry = map[string]MessageTypeInfo{
	"ern/v381/NewReleaseMessage": {
		Type:        reflect.TypeOf(ernv381.NewReleaseMessage{}),
		Namespace:   ernv381.Namespace,
		RootElement: "NewReleaseMessage",
	},
	"ern/v381/CatalogListMessage": {
		Type:        reflect.TypeOf(ernv381.CatalogListMessage{}),
		Namespace:   ernv381.Namespace,
		RootElement: "CatalogListMessage",
	},
	"ern/v381/PurgeReleaseMessage": {
		Type:        reflect.TypeOf(ernv381.PurgeReleaseMessage{}),
		Namespace:   ernv381.Namespace,
		RootElement: "PurgeReleaseMessage",
	},
	"ern/v383/NewReleaseMessage": {
		Type:        reflect.TypeOf(ernv383.NewReleaseMessage{}),
		Namespace:   ernv383.Namespace,
		RootElement: "NewReleaseMessage",
	},
	"ern/v383/CatalogListMessage": {
		Type:        reflect.TypeOf(ernv383.CatalogListMessage{}),
		Namespace:   ernv383.Namespace,
		RootElement: "CatalogListMessage",
	},
	"ern/v383/PurgeReleaseMessage": {
		Type:        reflect.TypeOf(ernv383.PurgeReleaseMessage{}),
		Namespace:   ernv383.Namespace,
		RootElement: "PurgeReleaseMessage",
	},
	"ern/v42/NewReleaseMessage": {
		Type:        reflect.TypeOf(ernv42.NewReleaseMessage{}),
		Namespace:   ernv42.Namespace,
		RootElement: "NewReleaseMessage",
	},
	"ern/v42/PurgeReleaseMessage": {
		Type:        reflect.TypeOf(ernv42.PurgeReleaseMessage{}),
		Namespace:   ernv42.Namespace,
		RootElement: "PurgeReleaseMessage",
	},
	"ern/v43/NewReleaseMessage": {
		Type:        reflect.TypeOf(ernv43.NewReleaseMessage{}),
		Namespace:   ernv43.Namespace,
		RootElement: "NewReleaseMessage",
	},
	"ern/v43/PurgeReleaseMessage": {
		Type:        reflect.TypeOf(ernv43.PurgeReleaseMessage{}),
		Namespace:   ernv43.Namespace,
		RootElement: "PurgeReleaseMessage",
	},
	"ern/v432/NewReleaseMessage": {
		Type:        reflect.TypeOf(ernv432.NewReleaseMessage{}),
		Namespace:   ernv432.Namespace,
		RootElement: "NewReleaseMessage",
	},
	"ern/v432/PurgeReleaseMessage": {
		Type:        reflect.TypeOf(ernv432.PurgeReleaseMessage{}),
		Namespace:   ernv432.Namespace,
		RootElement: "PurgeReleaseMessage",
	},
	"mead/v11/MeadMessage": {
		Type:        reflect.TypeOf(meadv11.MeadMessage{}),
		Namespace:   meadv11.Namespace,
		RootElement: "MeadMessage",
	},
	"pie/v10/PieMessage": {
		Type:        reflect.TypeOf(piev10.PieMessage{}),
		Namespace:   piev10.Namespace,
		RootElement: "PieMessage",
	},
	"pie/v10/PieRequestMessage": {
		Type:        reflect.TypeOf(piev10.PieRequestMessage{}),
		Namespace:   piev10.Namespace,
		RootElement: "PieRequestMessage",
	},
}

// GetRegisteredTypes returns all registered message types
func GetRegisteredTypes() map[string]MessageTypeInfo {
	result := make(map[string]MessageTypeInfo)
	for k, v := range messageRegistry {
		result[k] = v
	}
	return result
}

// New creates a new instance of the specified message type and version
// For message types with multiple root messages, uses the first one found
func New(messageType, version string) (interface{}, error) {
	// Find the first matching message type/version
	prefix := fmt.Sprintf("%s/%s/", messageType, version)
	for key, info := range messageRegistry {
		if strings.HasPrefix(key, prefix) {
			return reflect.New(info.Type).Interface(), nil
		}
	}
	return nil, fmt.Errorf("unknown message type: %s/%s", messageType, version)
}

// NewByMessageName creates a new instance of a specific message by name
func NewByMessageName(messageType, version, messageName string) (interface{}, error) {
	key := fmt.Sprintf("%s/%s/%s", messageType, version, messageName)
	info, ok := messageRegistry[key]
	if !ok {
		return nil, fmt.Errorf("unknown message: %s/%s/%s", messageType, version, messageName)
	}

	return reflect.New(info.Type).Interface(), nil
}

// DetectMessageType attempts to detect the message type, version, and message name from XML data
func DetectMessageType(xmlData []byte) (messageType, version, messageName string, err error) {
	// Parse just enough to get the root element and namespace
	decoder := xml.NewDecoder(strings.NewReader(string(xmlData)))

	for {
		token, err := decoder.Token()
		if err != nil {
			return "", "", "", fmt.Errorf("failed to parse XML: %w", err)
		}

		if startElement, ok := token.(xml.StartElement); ok {
			// Found the root element
			rootElement := startElement.Name.Local
			namespace := startElement.Name.Space

			// If no namespace in the element name, check attributes
			if namespace == "" {
				for _, attr := range startElement.Attr {
					if attr.Name.Local == "xmlns" || strings.HasPrefix(attr.Name.Local, "xmlns:") {
						namespace = attr.Value
						break
					}
				}
			}

			// Match against registered types
			for key, info := range messageRegistry {
				if info.RootElement == rootElement && info.Namespace == namespace {
					parts := strings.Split(key, "/")
					if len(parts) == 3 {
						return parts[0], parts[1], parts[2], nil
					}
				}
			}

			return "", "", "", fmt.Errorf("unknown DDEX message type with root element '%s' and namespace '%s'", rootElement, namespace)
		}
	}
}

// ParseAny automatically detects the message type and parses the XML accordingly
func ParseAny(xmlData []byte) (message interface{}, messageType, version string, err error) {
	// Detect the message type first
	msgType, ver, msgName, err := DetectMessageType(xmlData)
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to detect message type: %w", err)
	}

	// Create a new instance of the detected type
	message, err = NewByMessageName(msgType, ver, msgName)
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to create message instance: %w", err)
	}

	// Unmarshal the XML into the message
	err = xml.Unmarshal(xmlData, message)
	if err != nil {
		return nil, "", "", fmt.Errorf("failed to unmarshal XML: %w", err)
	}

	return message, msgType, ver, nil
}

// Parse parses XML data for a specific message type and version
func Parse(xmlData []byte, messageType, version string) (interface{}, error) {
	message, err := New(messageType, version)
	if err != nil {
		return nil, err
	}

	err = xml.Unmarshal(xmlData, message)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal %s/%s: %w", messageType, version, err)
	}

	return message, nil
}

// IsRegistered checks if a message type and version combination is registered
func IsRegistered(messageType, version string) bool {
	prefix := fmt.Sprintf("%s/%s/", messageType, version)
	for key := range messageRegistry {
		if strings.HasPrefix(key, prefix) {
			return true
		}
	}
	return false
}

// GetAvailableTypes returns a list of all available message types and versions
func GetAvailableTypes() []string {
	var types []string
	for key := range messageRegistry {
		types = append(types, key)
	}
	return types
}
